{"args":["--to","cocalc-html"],"start":1657305858307,"state":"done","time":1657305858586,"type":"nbconvert"}
{"backend_state":"running","connection_file":"/projects/e4ede0a6-a244-4cc8-b89c-11422c323425/.local/share/jupyter/runtime/kernel-ef8bee8e-fab2-43e2-8a1d-7e3807270d8c.json","kernel":"ds_env","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.13"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1657305734946,"exec_count":1,"id":"e9a906","input":"import pandas as pd\nimport plotly.express as px\nfrom datetime import datetime\n\npd.options.display.max_columns = 30","kernel":"ds_env","pos":1,"start":1657305734496,"state":"done","type":"cell"}
{"cell_type":"code","end":1657305734992,"exec_count":2,"id":"e6e40c","input":"spotify_df = pd.read_csv(\"data/spotify_data.csv\")\nspotify_df.info()","kernel":"ds_env","output":{"0":{"name":"stdout","text":"<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1556 entries, 0 to 1555\nData columns (total 23 columns):\n #   Column                     Non-Null Count  Dtype \n---  ------                     --------------  ----- \n 0   Index                      1556 non-null   int64 \n 1   Highest Charting Position  1556 non-null   int64 \n 2   Number of Times Charted    1556 non-null   int64 \n 3   Week of Highest Charting   1556 non-null   object\n 4   Song Name                  1556 non-null   object\n 5   Streams                    1556 non-null   object\n 6   Artist                     1556 non-null   object\n 7   Artist Followers           1556 non-null   object\n 8   Song ID                    1556 non-null   object\n 9   Genre                      1556 non-null   object\n 10  Release Date               1556 non-null   object\n 11  Weeks Charted              1556 non-null   object\n 12  Popularity                 1556 non-null   object\n 13  Danceability               1556 non-null   object\n 14  Energy                     1556 non-null   object\n 15  Loudness                   1556 non-null   object\n 16  Speechiness                1556 non-null   object\n 17  Acousticness               1556 non-null   object\n 18  Liveness                   1556 non-null   object\n 19  Tempo                      1556 non-null   object\n 20  Duration (ms)              1556 non-null   object\n 21  Valence                    1556 non-null   object\n 22  Chord                      1556 non-null   object\ndtypes: int64(3), object(20)\nmemory usage: 279.7+ KB\n"}},"pos":3,"start":1657305734949,"state":"done","type":"cell"}
{"cell_type":"code","end":1657305735192,"exec_count":3,"id":"73d0d4","input":"spotify_df.replace({' ':None}, inplace=True)\nspotify_df['Streams'] = spotify_df['Streams'].str.replace(',', '')\n\ninteger_columns = ['Artist Followers','Streams','Popularity','Duration (ms)']\nfor column in integer_columns:\n    spotify_df[column] = pd.to_numeric(spotify_df[column], downcast='integer')\n\nfloat_columns = ['Danceability','Energy','Loudness','Speechiness','Acousticness','Liveness','Tempo','Valence']\nfor column in float_columns:\n    spotify_df[column] = pd.to_numeric(spotify_df[column], downcast='float')\n\nspotify_df.dropna(inplace=True)\nspotify_df.reset_index(drop=True, inplace=True)    \n    \n#find special cases to convert to np.nan\ngood_date = 'YYYY-MM-DD'\n\nfor i, date in zip(spotify_df.index, spotify_df['Release Date']):\n    if len(date) < len(good_date):\n        spotify_df.at[i, 'Release Date'] = None\n        \nspotify_df = spotify_df.replace(to_replace=\"[]\", value = None)\n\nspotify_df.dropna(inplace=True)\nspotify_df.reset_index(drop=True, inplace=True)\n\ncolumns_to_drop = ['Index', 'Song ID']\nspotify_df.drop(columns_to_drop, axis=1, inplace=True)\n\n#sort the release dates into months\nfor i, date in zip(spotify_df.index, spotify_df['Release Date']):\n        new_dt = datetime.strptime(date, '%Y-%m-%d')\n        month = new_dt.strftime(\"%B\")\n        spotify_df.at[i, 'Release Date'] = month\n\nspotify_df.info()","kernel":"ds_env","output":{"0":{"name":"stdout","text":"<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1455 entries, 0 to 1454\nData columns (total 21 columns):\n #   Column                     Non-Null Count  Dtype  \n---  ------                     --------------  -----  \n 0   Highest Charting Position  1455 non-null   int64  \n 1   Number of Times Charted    1455 non-null   int64  \n 2   Week of Highest Charting   1455 non-null   object \n 3   Song Name                  1455 non-null   object \n 4   Streams                    1455 non-null   int32  \n 5   Artist                     1455 non-null   object \n 6   Artist Followers           1455 non-null   float64\n 7   Genre                      1455 non-null   object \n 8   Release Date               1455 non-null   object \n 9   Weeks Charted              1455 non-null   object \n 10  Popularity                 1455 non-null   float64\n 11  Danceability               1455 non-null   float32\n 12  Energy                     1455 non-null   float32\n 13  Loudness                   1455 non-null   float32\n 14  Speechiness                1455 non-null   float32\n 15  Acousticness               1455 non-null   float32\n 16  Liveness                   1455 non-null   float32\n 17  Tempo                      1455 non-null   float32\n 18  Duration (ms)              1455 non-null   float64\n 19  Valence                    1455 non-null   float32\n 20  Chord                      1455 non-null   object \ndtypes: float32(8), float64(3), int32(1), int64(2), object(7)\nmemory usage: 187.7+ KB\n"}},"pos":5,"start":1657305735009,"state":"done","type":"cell"}
{"cell_type":"code","end":1657305735582,"exec_count":4,"id":"4b4aab","input":"fig = px.histogram(spotify_df, x='Chord', y='Streams', barmode='group', width=700, height=450, text_auto=True)\nfig.update_xaxes(categoryorder='total ascending')\nfig.update_layout(title='Total Streams per Chord')\nfig.show()","kernel":"ds_env","output":{"0":{"data":{"iframe":"c032f856490a4aa9909df255fed95e3fa303ced2"}}},"pos":7,"scrolled":true,"start":1657305735238,"state":"done","type":"cell"}
{"cell_type":"code","end":1657305735757,"exec_count":6,"id":"abc860","input":"followBin = []\n\nfor i in spotify_df['Artist Followers']:\n    if i < 10000000:\n        followBin.append(\"0-10m\")\n        \n    elif i > 10000000 and i <= 40000000:\n        followBin.append(\"10m-40m\")\n        \n        \n    else:\n        followBin.append(\"40m+\")\nspotify_df['Artist Followers Bin'] = followBin\n\nfig = px.box(spotify_df, x='Streams', y='Artist Followers Bin', width=700, height=450, category_orders={\"Artist Followers Bin\": [\"0-10m\", \"10m-40m\", \"40m+\"]})\nfig.update_layout(title='Artist Followers Related to Amount of Streams')\n\n\nfig.show()","kernel":"ds_env","output":{"0":{"data":{"iframe":"9a6679c23273ea27367dd83ff171898e2454fb82"}}},"pos":9,"scrolled":true,"start":1657305735681,"state":"done","type":"cell"}
{"cell_type":"code","end":1657305735841,"exec_count":7,"id":"9e2a1d","input":"loudBin = []\n\nfor i in spotify_df['Loudness']:\n    if i <= -15:\n        loudBin.append(\"<-15\")\n    elif i > -15 and i <= -7:\n        loudBin.append(\"-15 to -7\")\n    else:\n        loudBin.append(\"-7 to 5\")\nspotify_df['LoudnessBin'] = loudBin\n\nfig = px.box(spotify_df, y='Popularity', x='LoudnessBin', category_orders={\"LoudnessBin\": [\"<-15\",\"-15 to -7\", \"-7 to 5\"]}, title=\"Popularity of a song compared to its loudness\", height=450, width=700)\nfig.update_layout(autotypenumbers='convert types')\nfig.show()","kernel":"ds_env","output":{"0":{"data":{"iframe":"1a224c603f042b0566948e07027b74d4be71a635"}}},"pos":11,"start":1657305735766,"state":"done","type":"cell"}
{"cell_type":"code","end":1657305735914,"exec_count":8,"id":"9a9b45","input":"followBin = []\n\nfor i in spotify_df['Artist Followers']:\n    if i <= 20000000:\n        followBin.append(\"<20M\")\n    elif i > 20000000 and i <= 40000000:\n        followBin.append(\"20M - 40M\")\n    else:\n        followBin.append(\">40M\")\nspotify_df['Artist FollowersBin'] = followBin\n\nfig = px.box(spotify_df, x='Popularity', y='Artist FollowersBin', category_orders={\"Artist FollowersBin\": [\">40M\", \"20M - 40M\", \"<20M\"]},title=\"Popularity of a song compared to the number of Artist Followers\", height=450, width=700)\nfig.update_layout(autotypenumbers='convert types')\nfig.show()","kernel":"ds_env","output":{"0":{"data":{"iframe":"35f717f958f33e06af1436dacfc326e8d23fcf9e"}}},"pos":13,"start":1657305735849,"state":"done","type":"cell"}
{"cell_type":"code","end":1657305735995,"exec_count":9,"id":"44c98b","input":"#How does valence affect popularity?\n\n#bin the valence data into groups of 0.1\nlabels = pd.IntervalIndex.from_tuples([(0, 0.1), (0.1, 0.2), (0.2, 0.3), (0.3, 0.4) , (0.4, 0.5), (0.5, 0.6), (0.6, 0.7), (0.7, 0.8), (0.8, 0.9), (0.9, 1), (1, 1.1)], closed='right')\nspotify_df['Valence Bins'] = pd.cut(x = spotify_df['Valence'], bins = labels).astype('str')\nnew_valence_bins = []\nfor vbin in spotify_df['Valence Bins']:\n    new_valence_bins.append(str(vbin))\nspotify_df['Valence Score'] = new_valence_bins\n\n#create figure\nfig = px.density_heatmap(\n    spotify_df,\n    x='Valence Score', \n    y=\"Popularity\", \n    category_orders={'Valence Score':['(0.0, 0.1]', '(0.1, 0.2]', '(0.2, 0.3]', '(0.3, 0.4]' , '(0.4, 0.5]', '(0.5, 0.6]', '(0.6, 0.7]', '(0.7, 0.8]', '(0.8, 0.9]', '(0.9, 1.0]', '(1.0, 1.1]']},\n    title='Density Map of Valence Vs. Popularity Score for Songs on Spotify',\n    width = 800,\n    height=500\n)\nfig.update_layout()\nfig.update_layout(autotypenumbers='convert types')\nfig.show()","kernel":"ds_env","output":{"0":{"data":{"iframe":"1ff3442970d2b6b06f88377e03a587657d6130ce"}}},"pos":15,"scrolled":true,"start":1657305735925,"state":"done","type":"cell"}
{"cell_type":"code","end":1657305736161,"exec_count":10,"id":"8e9e00","input":"#which is the best month to release a song\n\n#create figure\nfig = px.histogram(\n    spotify_df, x='Release Date', \n    y='Streams', \n    category_orders = {'Release Date':['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']},\n    title= 'Bar Chart of Month Song is Released vs. Popularity Score',\n    color = 'Release Date',\n    width =700,\n    height =450\n)\nfig.update_traces(showlegend=False)\nfig.show()","kernel":"ds_env","output":{"0":{"data":{"iframe":"b3a5e2ec4f0323622e57375dc1d44ad5162d5ca4"}}},"pos":17,"start":1657305735999,"state":"done","type":"cell"}
{"cell_type":"code","end":1657305736264,"exec_count":11,"id":"8f0961","input":"#Calculate avg streams per song in a month\n\n#calculate sum of song\nstreams_per_song = {'January': 0, 'February': 0, 'March': 0, 'April': 0, 'May': 0, 'June': 0, 'July': 0, 'August': 0, 'September': 0, 'October': 0, 'November': 0, 'December': 0}\nfor month in streams_per_song.keys():\n    ind_month = spotify_df[spotify_df['Release Date'] == month]\n    sum_streams = ind_month['Streams'].sum()\n    songs_in_month = spotify_df['Release Date'].str.count(month)\n    songs_in_month = songs_in_month.sum()\n    streams_per_song[month] = sum_streams / songs_in_month\n\n#convert to dict\ndf = pd.DataFrame(list(streams_per_song.items()), columns=['Month', 'Streams Per Song'])\n\n#plot figure\nfig = px.bar(df, \n             x='Month', \n             y='Streams Per Song',\n             title='Average Number of Streams Per Song Released in Each Month',\n             color = 'Streams Per Song',\n             width=700, height=450,\n            )\nfig.show()","kernel":"ds_env","output":{"0":{"data":{"iframe":"2b027fe3da3776a4d538c3e8eff027734df4229e"}}},"pos":21,"start":1657305736169,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"257375","input":"# Conclusion\n\nThis dashboard has found insights related to the popularity of songs in Spotify's top 200 Charts \\(2020\\-2021\\). The most important factors in a song's popularity are **what time of year it was produced, the loudness of the song, and the valence of the song.** The chord stream rate is mostly constant except for the D\\#/Eb chord which had the highest stream rate. The artist followers study shows conflicting information that artists with more followers have higher streams, yet they have the lowest popularity score. One additional explanation for the gap between total streams and popularity score could result from the different kinds of followers that artists have. Larger artists may have a lower popularity score because a portion of their followers only listen to them because other people do, so when it comes to a new song coming out from a top artist these followers may be less incentivized to actually play the music. On the other hand, smaller artists probably have more devout followers that are likely to click on their new song right away and cause a popularity surge.\n\nIn the past few years, Covid and especially the global quarantine has affected everybody in different ways. One thing everyone experienced in the recent past is spending more time alone and one of the best ways to ease the boredom is listening to music. Music never fails to change the mood and brighten anyone's day, but sometimes finding the right music can be a challenge. However, using this dashboard's metrics on popularity can help to find the right songs. Whether it be through certain chords, artist followers, or valence, these metrics can help you to find the songs that everybody else is enjoying.\n\n","pos":27,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2beea7","input":"An important part of the song industry and for music consumers is the way a song or album evokes a sense of happiness or, contrarily, sadness. Thankfully there is a metric called Valence which rates the positiveness of a song on a scale of 0 to 1 where one is the most bright and joyful. **Using this interesting metric, the density map above compares the valence score of a song to its determined popularity score.** The diagram shows high density where valence is from 0.3 to 0.7 and where popularity is from 70 to 80. This means that for songs that people generally like \\(around a popularity score of 70\\), most people gravitate towards a midway valence score. These songs are not too happy or sad but rather a more neutral standpoint as proven by the valence.\n\n","pos":16,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"551b78","input":"## Importing the database\n\nSpotify Top 200 Charts \\(2020\\-2021\\) [https://www.kaggle.com/datasets/sashankpillai/spotify\\-top\\-200\\-charts\\-20202021](https://www.kaggle.com/datasets/sashankpillai/spotify-top-200-charts-20202021)","pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"63c2cd","input":"**This bar chart shows the sum of streams per month.** As shown by the figure, the most streams occured in late spring to early summer. Beginning in August, the total number of streams decreases and steadily rises until February. While it may appear that certain months are more popular for streaming, an important factor to consider is the number of songs released in each month. In the next figure, the average streams per song in each month is investigated.\n\n","pos":18,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"67a032","input":"## Cleaning our dataset\n\nIn our dataset, we had to change all the numerical categories into floats from objects. We also had to drop all of the rows that had missing information by replacing those blanks with NaN's which we could remove with a line of code. After this step, our dataset was ready to be used in charts and graphs.\n\n","pos":4,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"71c9e4","input":"**This multi\\-box plot compares the number of artist followers to popularity.** The artists with a lower follower count have a higher popularity score compared to artists with a following greater than 40m. While artists with lots of followers get more streams, those streams are listened to over a longer period of time. Artists with fewer followers get streams very fast which most likely results in their songs having a higher popularity score. **This may reflect that artists with a lower following have a larger audience growth rate than artists with a large following.**\n\n","pos":14,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"83e4c4","input":"# Introduction\n\nThe dataset we are using for our dashboard is \"Spotify Top 200 Charts \\(2020\\-2021\\)\" \\([https://www.kaggle.com/datasets/sashankpillai/spotify\\-top\\-200\\-charts\\-20202021](https://www.kaggle.com/datasets/sashankpillai/spotify-top-200-charts-20202021)\\). We are using this dataset to see how different variables in the top 200 songs on Spotify affect how popular those songs are. The songs on the top 200 are there for a reason and we are using this dataset to dig deeper into why those songs are there. The popularity of songs can be measured in multiple ways, either through a popularity scoring \\(scored through 0\\-100\\)  determined by Spotify or through the number of streams the song gets on the platform.\n\n","pos":6,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ae00c1","input":"**This is a bar chart of the average streams per song of each chord.** The chords are ordered by the total number of streams in the previous figure. While the previous figure showed that C\\#/Db had the highest total streams and D\\#/Eb had the lowest total streams, the stream rate has a different distribution than the previous figure. **It appears that the songs written in D\\#/Eb have the highest stream rate, while the other chords have a similar stream rate.**\n\n","pos":8,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ba720b","input":"The main issue with the previous figure was that if a month happened to have more songs released in that time period then it was more likely that the sum of streams for that month would be greater. It is possible the number of songs in a month interfered with the objective popularity of songs released in that month. To solve this issue, the current figure shows the **average number of streams a song receives in the data set** instead of the sum of streams. The result of this graph **illustrates that December, May, June, and November are actually the top four months in which songs recieve the most streams**. This means that songs released in these months are more likely to be popular.\n\n","pos":25,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ca584d","input":"The chord or key of a song represents the musical scale the song was written in. **This bar chart displays the total streams listened in each chord.** This figure shows that the most popular song chord is C\\#/Db and the least popular is D\\#/Eb. The other chords have total streams that range from 650 million to 910 million total streams. **The sum of streams may reflect the total number of songs released in each chord, so the stream rate per chord will be analyzed.**\n\n","pos":7.25,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ca83b3","input":"Loudness measures the volume of a song using a relative scale made by Spotify. In this scale, the loudest songs are positive and the quietest songs are negative. This **multi\\-box plot compares a song's popularity to its loudness.** Most songs that have a loudness from \\-15 to 5 have a median popularity of 72. However, there is a drop in popularity when the loudness is less than \\-15. **This supports that middle volume and loud volume songs are most popular.**\n\n","pos":12,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"dbbc77","input":"## Importing our tools\n\nFor our plots we used pandas and plotly. Pandas for the database and plotly to use for all the plots/graphs.\n","pos":0,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e7b1e2","input":"This multi\\-box plot **compares the amount of followers an artist has and the number of streams each song get.** The streams in the Spotify 200 Charts range between 4 million to 10 million streams. The median and third quartile streams for artists who have a following of 40m\\+ are the highest. There are outliers for the groups of artists with fewer followers, but the interquartile ranges are smaller and less than the 40m\\+ group. **This supports that artists with a larger following receive the most streams.** \n\n","pos":10,"state":"done","type":"cell"}
{"end":1657305735674,"exec_count":5,"id":"5c9335","input":"streams_per_song = {'D#/Eb':0,'E':0,'A#/Bb':0,'A':0,'F#/Gb':0,'F':0,'D':0,'G#/Ab':0,'G':0,'B':0,'C':0,'C#/Db':0}\nfor chord in streams_per_song.keys():\n    ind_chord = spotify_df[spotify_df['Chord'] == chord]\n    sum_streams = ind_chord['Streams'].sum()\n    songs_in_chord = len(ind_chord['Chord'])\n    #songs_in_chord = songs_in_chord.sum()\n    streams_per_song[chord] = sum_streams / songs_in_chord\n\n#convert to dict\ndf = pd.DataFrame(list(streams_per_song.items()), columns=['Chord', 'Streams Per Song'])\n\n#plot figure\nfig = px.bar(df, x='Chord', y='Streams Per Song',  width=700, height=450, title= 'Average Streams Per Song Vs Chord', text_auto=True, category_orders = {'Chord':['D#/Eb','E','A#/Bb','A','F#/Gb','F','D','G#/Ab','G','B','C','C#/Db']})\nfig.show()","kernel":"ds_env","output":{"0":{"data":{"iframe":"7cb9660a9507347d6464c317680548520620d81c"}}},"pos":7.75,"start":1657305735591,"state":"done","type":"cell"}
{"id":"865d8e","input":"","pos":31,"type":"cell"}
{"id":0,"time":1657305540277,"type":"user"}
{"last_load":1657294397193,"type":"file"}